// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                          Int                 @id @default(autoincrement())
  email                       String              @unique
  displayName                 String              @unique
  intraId                     Int                 @unique
  invalidateTokenIssuedBefore DateTime?
  lockUntil                   DateTime?
  password                    String
  isEnabledAvatar             Boolean             @default(false)
  isEnabled2FA                Boolean             @default(false)
  chatMessage                 ChatMessage[]
  joinedRoom                  ChatUserRelation[]
  ownedRoom                   ChatRoom[]
  chatroomAttribute           ChatUserAttribute[]
  followingUser               FriendRelation[]    @relation("followingUser")
  followedUser                FriendRelation[]    @relation("followedUser")
  blockingUser                BlockRelation[]     @relation("blockingUser")
  blockedUser                 BlockRelation[]     @relation("blockedUser")
  userRankPoint               UserRankPoint?
  matchUserRelation           MatchUserRelation[]
}

model UserAvatar {
  id           Int      @id @default(autoincrement())
  userId       Int      @unique
  mime         String
  avatar       Bytes
  lastModified DateTime @default(now()) @updatedAt
}

model TotpSecret {
  id     Int    @id @default(autoincrement())
  userId Int    @unique
  secret String
}

model FriendRelation {
  user         User @relation(name: "followingUser", fields: [userId], references: [id])
  userId       Int
  targetUser   User @relation(name: "followedUser", fields: [targetUserId], references: [id])
  targetUserId Int

  @@id([userId, targetUserId])
}

model BlockRelation {
  user         User @relation(name: "blockingUser", fields: [userId], references: [id])
  userId       Int
  targetUser   User @relation(name: "blockedUser", fields: [targetUserId], references: [id])
  targetUserId Int

  @@id([userId, targetUserId])
}

model ChatRoom {
  id              Int                 @id @default(autoincrement())
  roomName        String
  roomType        RoomType            @default(PUBLIC)
  roomPassword    String?
  owner           User                @relation(fields: [ownerId], references: [id])
  ownerId         Int
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @default(now()) @updatedAt
  chatMessage     ChatMessage[]
  roomMember      ChatUserRelation[]
  memberAttribute ChatUserAttribute[]
}

enum RoomType {
  PUBLIC
  PRIVATE
  LOCKED
  DM
}

model ChatUserRelation {
  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId     Int
  chatRoom   ChatRoom   @relation(fields: [chatRoomId], references: [id], onDelete: Cascade)
  chatRoomId Int
  memberType MemberType @default(MEMBER)

  @@id([userId, chatRoomId])
}

model ChatUserAttribute {
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      Int
  chatRoom    ChatRoom @relation(fields: [chatRoomId], references: [id], onDelete: Cascade)
  chatRoomId  Int
  bannedEndAt DateTime @default(now())
  mutedEndAt  DateTime @default(now())
  readenUntil Int      @default(0)

  @@id([userId, chatRoomId])
}

enum MemberType {
  MEMBER
  ADMIN
}

model ChatMessage {
  id         Int      @id @default(autoincrement())
  chatRoom   ChatRoom @relation(fields: [chatRoomId], references: [id], onDelete: Cascade)
  chatRoomId Int
  user       User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  userId     Int?
  createdAt  DateTime @default(now())
  content    String
}

// ユーザーのランクポイント
//
// ランクポイントはランクマッチの勝敗によって変動する｡
model UserRankPoint {
  id        Int  @id @default(autoincrement())
  user      User @relation(fields: [userId], references: [id])
  userId    Int  @unique
  rankPoint Int  @default(1500)
}

// 試合結果
//
// 勝者敗者はスコアから算出可能なのでDBには保存しない｡
model MatchResult {
  id                String              @id // UUIDv4; 外部から与える
  matchType         MatchType
  userID1           Int // User.id
  userScore1        Int
  userID2           Int // User.id
  userScore2        Int
  endAt             DateTime // 試合終了日時
  matchUserRelation MatchUserRelation[]
  config            MatchConfig?
}

enum MatchType {
  RANK
  CASUAL
  PRIVATE
}

// マッチ設定
model MatchConfig {
  id       Int         @id @default(autoincrement())
  result   MatchResult @relation(fields: [matchID], references: [id])
  matchID  String      @unique
  maxScore Int // 何点取ったら勝利か
  speed    Float // 球の速度
}

// マッチとユーザーの関連テーブル
model MatchUserRelation {
  id          Int         @id @default(autoincrement())
  user        User        @relation(fields: [userID], references: [id])
  userID      Int
  matchResult MatchResult @relation(fields: [matchID], references: [id])
  matchID     String
  @@unique([userID, matchID])
}
